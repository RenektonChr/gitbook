# 前端性能优化服务器知识

## 零、前言

+ HTTP请求的具体过承（前置知识，这在以前是讲过的）

# 一、浏览器渲染过程

## I、HTTP处理流程（大概过程）

1. 输入网址并回车
2. 解析域名
3. 浏览器发送http请求
4. 服务器处理请求
5. 服务器返回HTML响应
6. 浏览器处理HTML页面
7. 继续请求其他资源

## II、NavigationTiming详解

### 什么是NavigationTiming？

NavigationTiming就是从发出请求时到页面渲染到浏览器上的一个完整的流程。用来分析性能，NavigationTiming还提供了一套JavaScriptAPI，参见[Mozilla文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigation_timing_API)。我们可以使用JS来调用API来监测性能。    

### NavigationTiming流程图

<img src="../assets/images/chapter10/navigation-timing.png" alt="node-app.png" style="zoom:80%;" />

### NavigationTiming详细图解

我们先看总体的步骤，也就是蓝色方块所代表的内容。  

1. 提示卸载（Prompt for unload）

   当我们输入url的时候会跳转到新的页面，在这之前浏览器要把原来旧的页面（包括空白页）卸载掉，卸载掉之后同时清空了内存，只一步实际上就可以看做是一个初始化，第一步就是执行的这个操作，也就是所谓的提示卸载。

2. 重定向以及卸载（redirect && unload），这两块是并行的。

   这里的重定向指的包括本地的强制缓存重定向和HTTP缓存协商之后的重定向，我们先来讨论非首次访问的情况，这种情况下会先去判断制缓存内的内容，如果强制缓存可以使用，那毫无疑问就是用强制缓存中的内容，如果不能使用，就正常往后走，走到response相应，后端可能会告诉我们缓存还没有失效，那么我们会跳回redirect这一步骤，使用强制缓存。现在我们要讨论第二种情况，如果本身就没有缓存，那么就会跳过redirect以及它之后的App cache，直接跳到和网络相关的DNS以及TCP了。unload则是要卸载掉上一个页面，这里是性能可能产生瓶颈的第一个地方。

3. 应用缓存（APP cache）

   如果强制缓存在并且没有过期，就会使用强制缓存。如果已经过期了，理所当然的就会通过网络来请求数据，这里需要注意一个非常重要的点，通过网络请求数据，会通过DNS查询，然后建立TCP连接，建立连接之后，浏览器发送HTTP请求，服务器响应这里可能会告诉浏览器，本地缓存并没有失效，这时整个过程会回到redirect这一步骤，然后从新经过APP cache来取用本地的缓存。当然如果压根儿就不存在本地缓存，肯定是直接请求后端服务器中的数据，这毫无疑问。由于App cache这里的缓存操作属于IO，所以App cache是第二个可能产生性能瓶颈的地方。

4. DNS解析（DNS）

   强制缓存过期或者根本不存在缓存的情况下，发送HTTP请求即建立tcp连接之前都会进行DNS查询，把url的字符串所代表的的ip地址拿到，实际上DNS查询就是拿一个URL的字符串取请求一个IP地址，这个步骤是可能出现性能瓶颈的第三个地方。这就需要对于DNS查询的底层协议做分析（下文会有解答）。

5. TCP

   建立TCP连接，通过三次握手进行连接，需要在Server端和Client端进行往返的通信，如果是https，还需要有一个安全连接TSL层面上的连接。建立TCP连接是第四个可能出现性能瓶颈的地方。通常TCP是肯定会出现性能瓶颈的，因为他是在服务器和客户端之间进行三次的通信（三次握手），并且与前后的DNS和Request这两个步骤都有必然的联系，对于前面的DNS采用的是就近原则，后面的请求发送还要收到通信质量的影响，所以必然会有性能的瓶颈（详细的解答请看下文）。

6. Request

   建立完链路，接下来就是应用层协议，也就是发送请求了，我们观察这一步骤的标签，也就是相关的事件节点会发现有请求开始的时间，响应开始的时间，响应结束的事件，但是唯独没有请求结束的时间，其实这并不是没有，只是这个时间是不可知的，对于我们来说是透明的。至于原因，下文我们会详细讲解。

7. Response

   服务器响应。响应回来的数据会从流转化成文本，也就是HTML。

8. Processing

   浏览器是不能直接处理HTML文本的，浏览器能处理的只能是DOM，所以Processing就是处理dom相关的操作。

9. onLoad

   HTML的onLoad事件，完事儿。

我们再看一下方块上用线连接的标签，这些标签表示的是一个个的时间节点。详细介绍如下：  

+ navigationStart：开始加载的时间点。在这时间节点真正的流程正式开始。
+ redirectStart：重定向开始的时间节点。
+ redirectEnd：重定向结束的时间节点。redirectStart与redirectEnd时间段就是整个重定向的时间段。
+ unloadStart：卸载上一个页面开始的时间点。
+ unloadEnd：卸载上一个页面结束的时间点。卸载页面会把页面在内存中的所有资源全部清空。unloadStart和unloadEnd之间的时间段就是卸载上一个页面的时间。这就引发了一个问题，为什么redirect和unload能够同时进行。这个问题我们稍后解答。
+ domianLookupStart：DNS解析开始时间
+ domainLookupEnd：DNS解析结束时间
+ connectStart：TCP连接开始时间
+ connectEnd：TCP连接结束时间，connectStart和connectEnd这中间的事件在做三次握手。
+ secureConnection：安全连接，这个是个可选项，在https的时候会进行连接，用于交换证书或者交换秘钥等等（TLS）。
+ requestStart：请求开始的时间。
+ responseStart：响应开始的时间，是服务器返回的数据的第一个字节被客户端收到的时间。这就说明了一个问题如果请求时间过长，那么主要的原因就是服务器响应的时间长。
+ responseEnd：响应结束的时间，是服务器返回的数据的最后一个字节被客户端收到的时间。这就说明响应时间过长的原因有两个，一个是数据过大，一个是网络环境太差，如果数据过大我们就要压缩数据，把gzip打开，如果是链路的问题我们可以架设镜像服务器，尽量使链路最短。
+ domLoading：把HTML转换成DOM。
+ domIntereactive：处理DOM。
+ domContentLoaded：加载dom。
+ domComplete：DOM操作完成。

### 为什么unload会产生性能瓶颈？

我们在卸载一个页面的时候，这个动作会有对应的一个事件，这个事件中可能会存在很多操作，比如说回收这个页面在内存中的资源，还有可能会在unload的时候向服务器发送请求，另外如果你的页面上有一些很复杂的数据结构，在unload事件中要把这些数据所占据的内存释放掉等等，

### 为什么redirect和unload能够同时进行？

只有unload之后下一个页面才能进行渲染，redirect是准备拿资源，redirect的这个时间段还没有真正的拿资源，只是一个准备动作，这就导致redirect和unload没有严格的先后顺序，两者之间没有相互依赖，所以两者可以并行执行。

### redirect、App cache都做了什么？

只要是有redirect就会对缓存进行操作，自然就到了App cache阶段，缓存毫无疑问是IO操作，这也是整个流程中第二个可能出现性能瓶颈的地方。这个很好理解，因为我们都知道只要是IO操作就必定是耗费时间的。我们在network查看http请求的时候会看到Size参数，这里面就会出现两种缓存memory cache和disk cache，前者是内存的缓存，后者是磁盘的缓存。这两者都是本地的缓存，都可以归入App cache中，频繁读取的资源会放入memory cache中，不会频繁读取的内容会放在disk cache中，因为在内存中读取，总比在磁盘上读取要快。这两种缓存的判断使用，根据浏览器的算法来决定。

### 为什么DNS会产生性能瓶颈？

DNS的底层（传输层）协议是UDP，UDP是要比TCP的速度快，因为UDP是不需要握手的，尽管是比TCP快，但是DNS解析的IP地址会影响到后续的流程，因为我们需要知道具体的IP地址才能请求资源，有一种情况就是我们做了很多镜像服务器，有的距离我们近，有的距离我们远（这里说的远包括网络上的距离和地理距离），如果两个服务器都在北京，一个是联通的一个是移动的，我们如果通过联通的网络访问移动的IP，那么毫无疑问就会慢，如果一台服务器在北京，另一台在洛杉矶，这种地理位置上的远近也会影响速度，信号的传输是以光速传输，速度一定的情况下，地址位置越远，速度越慢。针对这个问题我们使用CDN来解决，根据就近原则来找一个最近的服务器，这个请求的速度就会快一些。

### 为什么TCP会产生性能瓶颈？

第一，TCP是有链接的连接，他的链接依靠的是三次握手，三次握手需要在S端和C端进行往返通信，耗费时间。第二、TCP的连接是为了后续的请求的发送，这严重依赖了网络传输的环境，如果网络环境不好，那么就会出现丢包的情况，一旦丢包就需要重新发送，这就直接导致了队首阻塞问题。第三、TCP连接也会收到DNS的影响，因为TCP的连接快慢一部分取决于IP地址的远近。综上就是对于TCP性能瓶颈的分析，而且TCP一旦出现瓶颈，这个影响是很严重的。

### Request为什么唯独没有请求结束的时间？

首先明确一下请求结束的概念，客户端发送请求实际上是一个流，只有服务器接收到这个流的最后一个字节的时候，请求才算真正结束，但是我们的NavigationTiming这个过程是跑在客户端上的，所以服务器什么时候接收到了请求流的最后一个字节我们是无法知道的，所以请求结束的时间点虽然存在，但是对于我们来说是不可知的。

### NavigationTiming流程图的大致划分

我们看一下NavigationTiming的流程图会发现，这个流程图大致可以分为三部分，第一部分是Prompt for unload、redirect && unload、APP cache这三个步骤，因为这三个步骤全部是和浏览器相关的，在第一部分中我们只能做对于浏览器的优化。第二部分则包括DNS、TCP、Request和Response这四个步骤，其中request和response中间是没有间断的，因为对于Request和Response这两者我们无法在时间上严格区分。也就是说对于人来说这两个步骤是透明的我们无法看见。我们可以发现第二部分这四个步骤完全是和网络相关，所以针对第二部分我们可以做的是对于网络的优化。其实严格来说第一部分的App Cache和网络也有一定的关系。

# 二、DNS详解

## I、什么是DNS？

DNS（Domain Name System），域名系统，用于将域名转换为IP。

## II、概念澄清

### 什么是顶级域名？

形如`.com`、`.cn`、`.net`、`.org` 属于顶级域名。

### 什么是一级域名？

顶级域名加一个点就是增加一级域名，例如`baidu.com` 是一级域名，`www.baidu.com`就是二级域名。

### 什么是SOA？

SOA（Start Of Authority，起始授权记录），一个区域解析库有且只能有一个SOA记录，而且必须放在第一条。

# 三、TCP三次握手

# 四、HTTP缓存机制

# 五、CDN集群

