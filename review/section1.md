

# 复习笔记一

1. LHS和RHS对于变量声明提升的影响
2. JS的入口函数——闭包
3. 块级作用域只对let和const生效
4. 块级作用域中函数的声明和函数声明的重写，浏览器的优化。
5. this 指向性问题。
   1. new和原型对象属性的优先级
   2. bind和箭头函数改变this的问题
   3. 对象方法的简写对于this没有影响
   4. 定时器中this的指向问题
6. 严格模式：strict在函数作用域内才好用。（全局也是一个匿名函数）
7. JS的两种引用方式
   1. 函数的参数是按值传递（注意这里的值到底是什么）
8. 逗号表达式
9. 正则的lastIndex
   1. 正则的深克隆和浅克隆
10. Buffer   buffer的克隆
11. hash碰撞



### 面试题

**Q：强缓存和协商缓存**

1. 浏览器在**第一次请求服务器**的时候，本地肯定是没有缓存的，所以就向服务器发起请求，服务器肯定要返回数据和缓存协商，这时候服务器会制定缓存策略，是否缓存，设置缓存时间（Expires和Cache-Control），Etag、Last-Modifired等，浏览器接收到数据进行解析和渲染。
2. 浏览器第N（N > 1）次请求：
   1. 要检查有没有强制缓存，如果强制缓存没有过期那就直接在本地缓存中取出数据，直接作为响应并渲染。
   2. 如果强制缓存过期了那么就走协商缓存（优先级是Etag > LastModified）：
      1. 优先检查Etag，Etag放在请求头的If-None-Match，与服务器中保存的md5对比，如果相同返回304，直接从本地缓存中获取数据，如果不同，直接请求服务器的数据。
      2. 如果没有Etag，则检查Last-Modified，If-Modified-Since中存储的是时间戳，对比时间戳，如果相同返回304，直接从本地缓存中获取数据，如果不同则从服务器获取数据。
      3. 不管是Etag还是Last-Modified，如果对比服务器上的md5或者时间戳不同，从服务器上获取数据，服务器会进行新一轮的缓存协商，也就是缓存策略的制定。
      4. **Etag和Last-Modify同时用是为了更加严密**



**Q：说一说cookie，cookie前端可读写么**

cookie是前端本地存储的一种方式，存储的内容一般由服务器决定，所以一般也称服务器给前端种cookie，存储的大小和个数要根据浏览器来定，不同的浏览器存储的大小和个数不定。

前端是存在对于cookie读写的API的，但是具体的读写权限，要根据服务器的http-only的bool值来定，为true则对于前端是不可操作的，为false则可以操作。



**Q：settimeOut准么为什么**

setTimeOut并不准确，但是使用这些方法会存在时间偏差的问题，这是由于 廏厲 的程序执行机制造成的，settimeOut 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。



**Q：url从输入到页面渲染完成发生了什么？**

1. 浏览器发出请求的指令
2. 确定是否能连接到网络，然后再确定网络的连通性。
3. DNS解析。域名 ----> IP
4. 建立TCP连接，通过路由技术找到一个最优的链路。
5. 通过反向代理请求会落到一个服务器上
6. 服务器根据请求会把内容准备好。
7. 按照最优的路径返回回去。
8. 浏览器接收到响应，解析和渲染（解析和渲染的具体过程，参见webkit渲染机制）。







Q1: 尾调用递归