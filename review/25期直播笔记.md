# 25期直播笔记

## 专题二

### HTTP那些事儿（上）

1. [00:11:37]请求模型
   1. 两端，两个动作
   2. 协议（必要）
2. [00:20:35] 浏览器行为与HTTP协议（建立连接）
   1. 处理流程（建立连接）
   2. 经典面试题
3. [00:44:52]HTTP协议
   1. 怎么使用terminal追踪路由（拓展）
   2. HTTP的发展史
   3. 七层、四层协议栈
   4. 视频相关的协议（套接字）
4. [01:22:40] HTTP工作过程
5. [01:34:05] HTTP请求和响应数据包的分解
6. [02:03:00] Restful
7. [02:07:00] 预检请求
8. [02:08:00]HTTP状态码
9. [02:20:00] setCookie，httponly

### HTTP那些事儿（下）

1. [00:13:00] 密码学
2. [00:39:50] 证书、CA
3. [00:59:08] SSL/TLS
4. [01:04:08] SSL/TLS握手
5. [01:23:50]HTTP2（跳过休息）
   1. http1和2的区别
   2. http2的消息推送
6. [01:40:10]HTTP2二进制分帧层、多路复用
7. [01:55:00]HTTP3
8. [02:10:10]队首阻塞
9. [02:23:16]反向代理
   1. 反向代理的用途

### 大规模NodeJS项目架构优化

1. [00:10:00] SPA、MPA、MPA + SPA
2. [00:19:52] BFF
3. [00:44:52] 异步IO
   1. 分布式IO
4. [00:55:47] 文件操作符
5. [01:05:36] Node使用libuv对eventloop
6. [01:15:36] Node宏任务、微任务的api
7. [01:27:45] 函数式编程、高阶函数
8. [01:34:00] V8（后面会仔细讲解）
9. [01:57:00] MVC  .net多层架构、服务器集群

### 前端工程化Linux预备知识

1. [00:23:00] 进程  线程  协程
2. [00:27:00] 进程
3. [00:45:00] 进程、线程、协程之间的关系
4. [01:00:23] IO密集型和CPU密集型的区别
5. [01:16:38] 操作系统对于进程和线程的设计
6. [01:24:05] 协调机制
   1. 为什么要有线程
7. [01:34:26] 多想成的进程结构
8. [01:41:00] Linux进程相关的命令
9. [01:43:17] PM2源码分析
10. [02:18:15] node 守护进程的启动方式
11. [02:21:16] Linux 免密登录

### 从小到大论前端项目集成

1. [00:11:45] CI持续集成
2. [00:17:22] CD持续交付持续部署
3. [00:24:55] 项目上线全流程
4. [00:44:52] SVN开发
5. [01:01:30] 持续集成思维导图
6. [01:11:10] 自动化编译、前端模块化
7. [01:24:50] 前端资源定位
8. [01:35:05] npm发包流程
9. [01:51:00] 手写cli

### 前端性能优化必备服务器知识

1. [00:15:20] 前端性能优化依据 Navigation Timing
2. [00:35:58] 
3. [01:28:58] DNS
4. [01:58:58] 三次握手四次挥手
5. [02:04:10] 图解上次
6. [02:09:20]SYN和ACK的意义

### Chrome浏览器的渲染内幕

1. [00:12:04] 浏览器的进化
2. [00:30:20] userAgent 的发展
3. [00:33:04] 现代浏览器的特征
4. [00:33:04] 现代浏览器的特征
   1. 浏览器是如何实现多页面进程是如何管理的
5. [00:47:13] 常见的渲染引擎
6. [00:51:29] 渲染引擎结构和工作流程
7. [01:34:35] chrome架构
8. [01:54:29] chrome渲染过程
9. [02:04:29] 栅格化

### 前端架构与性能优化那些事儿

1. [00:21:52] 性能优化第一阶段
   1. CDN的优点
2. [00:33:20] 离线缓存JS文件/如何管理离线缓存
3. [00:46:10] 缓存优先级
4. [01:01:40] 为什么开启Http2
5. [01:22:34] JS CSS 阻塞dom的问题
6. [01:37:17] 渲染过程总结（流程图）
7. [01:38:50] 网页渲染实战代码
   1. 网页分层的概念、合成层



## 专题六

### 从零手写React SSR

1. [00:15:00] 客户端渲染的优缺点
2. [00:50:00] 服务端搭建
3. [01:16:50] 跳过休息
4. [01:18:00] 注水 / 脱水
5. [01:32:00] 处理请求
6. [01:41:10] 处理 redux
7. [01:52:40] 注水
8. [01:41:10] 处理 redux

### React17最新API + 原理深入①

1. [00:17:29] React 17.0 源码中的配置文件和相关的包
2. [00:21:05] 如何看源码
3. [00:27:34] React-dom render中的批处理
4. [00:40:10] React的演进
5. [00:51:38] 优先级的讲解
6. [01:12:40] Suspense 阻塞 CPU 任务 的 demo 演示
7. [01:17:00] lanes / 优先级的迭代
8. [01:29:00] lanes 的位运算
9. [01:35:45] 回顾/ 总结
10. [01:42:10] 调度逻辑 (再回顾)
11. [01:59:10] 上下文的位运算
12. [02:02:40] 调度的源码解析
13. [02:13:51] MessageChannel 的消息通信
14. [02:28:30] 回顾/ 总结

### 手写Recoil源码TS版本

1. [00:22:55] recoil 文档 / API
2. [00:32:10] 手写Recoil
3. [00:37:45] recoil 的前置代码 -> 发布订阅
4. [00:43:45] any  / unknown / 泛型

### React17最新API + 原理深入②

1. [00:13:40] Reconciler 协调器
2. [00:19:15] Fiber tree
3. [00:23:06] 双缓存结构 / workInProgress Fiber Tree
4. [00:27:50] 离屏 canvas 优化
5. [00:30:00] React 和 Vue 的优化方向
6. [00:32:40] 构建 Fiber Tree 的过程
7. [00:43:00] beginWork ---- 父子组件的渲染顺序
8. [01:03:28] 源码 Function Component
9. [01:07:28] Class Component
10. [01:18:17] completeUnitOfWork
11. [01:35:50] dom diff
12. [01:44:10] 单节点diff
13. [01:48:05] 多节点diff
14. [02:04:40] render - commitContext
15. [02:07:10] 3个阶段
16. [02:16:20] useEffect  / useLayoutEffect
17. [02:19:10] 源码
18. [02:23:35] react - reconciler



## 专题六（下）

### Webpack在一线中的优化

1. [00:13:00] 初始化项目
2. [00:18:00] 跳过唠嗑
3. [00:25:50] 安装webpack4
4. [00:27:40] 生产和开发环境的区别
5. [00:37:20] 跳过唠嗑
6. [00:43:00] webpack的快慢
7. [00:47:00] webpack4：babel-loader
8. [00:51:00] 打包差异 webpack4 + cache-loader
9. [01:04:00] loader和JIT / swc-loader
10. [01:14:50] 跳过休息
11. [01:27:30] webpack5和Prepack
12. [01:35:40] Prepack和函数式编程的替换模型
13. [01:35:40] ESBuild loader 和 压缩
14. [01:45:40] terser-plugin压缩提速
15. [01:53:30] webpack对Prepack的实现
16. [02:00:00] speed-measure-webpack-plugin



## 专题十

### 前端工程师必会的V8

1. [00:18:30] 为什么SWC快
2. [00:22:50] libuv的机制
   1. eventloop：浏览器和node的区别
3. [00:27:00] 三大观察者 idel观察者、IO观察者、check观察者
4. [00:30:50] libuv的七个主要阶段/源码
5. [00:36:20] easy monitor
6. [00:58:14] idle阶段/IO poll 阶段和callback的区别
7. [01:06:15] 和浏览器的区别
8. [01:36:01] V8的几个感念
9. [01:39:01] JIT / GC / 内联缓存 / 隐藏类
10. [01:44:16] DSL NLP AST
11. [01:53:25] AST / 词法分析
12. [01:53:25] 闭包 / 一等公民 / 惰性解析
13. [02:08:18] 在node中跟踪V8的一些命令 / 参数

### 前端中常用的设计模式TS实现

1. [00:09:00] (接上一节) 惰性解析
2. [00:28:40] V8的两个编译器没有解释器
3. [0031:45] V8反优化
4. [00:42:40] V8的运行流程图（续）
5. [00:47:20] 类型检查
6. [01:01:50] 隐藏类
7. [01:03:15] D8  调试V8
8. [01:53:24] 设计模式
9. [01:58:50] 单例模式
10. [02:03:00] 观察者模式

### 前端架构师启蒙课终极之战

1. [00:10:10] 工厂模式
2. [00:22:10] 代理模式
3. [00:33:00] 代理模式的demo
4. [00:44:40] 策略模式
5. [00:51:10] 命令模式
6. [01:02:20] 责任链模式
7. [01:21:15] 装饰者模式
8. [01:27:40] 享元模式

### 前端与黑客安全

1. [00:13:10] 安全态势、行业趋势
2. [00:20:00] 渗透测试标准
3. [00:25:40] 渗透初期/靶机
4. [00:29:41] 防火墙 Little Snitch
5. [00:35:50] web信息收集阶段
6. [01:08:40] 前端的混淆技术
7. [01:24:10] JJ Encode
8. [01:35:30] 代码压缩进图片/CSS
9. [01:44:00] 跳过唠嗑
10. [01:49:50] CSRF攻击——流程

















