# 工单系统技术栈汇总文档

## 一、主要技术栈

1. UI框架：[React 18](https://zh-hans.reactjs.org/)
2. 状态管理工具：[Recoil](https://recoiljs.org/zh-hans/)
3. CSS库：[tailwind CSS](https://tailwindcss.com/)
4. 开发语言：[TS](https://www.typescriptlang.org/)
5. 打包工具：[Webpack](https://webpack.js.org/)
6. JS编译工具：[SWC](https://swc.rs/)



> 自己写Webpack的打包是为了提高编译的速度
>
> 避免当前跳房子PC项目打包异常缓慢的问题



## 二、HTTP请求——Service模块封装

### I、Service模块的能力——大概设计

1. 区别不同的环境，根据不同的环境给出不同的`BASE_URL`、`TIME_OUT`等。
2. 使用面向对象的编程范式，基于类对Axios进行封装。
3. 划分不同的封装粒度：
   1. 类层面的拦截
   2. 对象层面的拦截
   3. 方法层面的拦截
4. 功能上要包含以下几个方面：
   1. token的携带
   2. 全局错误的拦截
   3. loading效果的封装以及控制



### II、具体设计——代码实现及拆解

1. 区分环境——`servive/config/index.ts`

   ```typescript
   /**
    * 用于获取当前的环境变量
    * 根据当前环境导出与环境有关的各种变量
    */
   const ENV = process.env.NODE_ENV || 'development';
   let BASE_URL = 'http://httpbin.org';
   let BASE_API = 'http://httpbin.org';
   const TIME_OUT = 10000;
   
   if(ENV === 'development'){
     BASE_URL = 'http://httpbin.org';
     BASE_API = 'http://httpbin.org';
   }else {
     BASE_URL = 'http://example.prod.com';
     BASE_API = 'http://example.prod.com/api';
   }
   
   export { BASE_URL, BASE_API, TIME_OUT };
   ```

   通过webpack注入的`NODE_ENV`区分环境，设置不同的公共变量。

2. 创建目录及文件

   Request类——`servive/request/index.ts`

   ```typescript
   import axios from "axios";
   import type { AxiosInstance } from "axios";
   import type { HRRequestInterceptor, HRRequestConfig } from "./type";
   
   const DEFAULT_LOADING = false;
   
   class HRRequest {
   	// Axios实例
     instance: AxiosInstance;
     // interceptor拦截器
     interceptor: HRRequestInterceptor;
     
     constructor(config: HRRequestConfig) {
       this.instance = axios.create(config);
     }
   }
   
   export default HRRequest;
   ```

3. 创建type.ts——`servive/request/type.ts`

   ```typescript
   import type { AxiosRequestConfig, AxiosResponse } from "axios";
   
   export interface HRRequestInterceptor<T = AxiosResponse> {
     requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig;
     requestCatchInterceptor?: (error: any) => any;
     responseInterceptor?: (response: T) => T;
     responseCatchInterceptor?: (error: any) => any;
   }
   
   export interface HRRequestConfig<T = AxiosResponse> extends AxiosRequestConfig {
     interceptor?: HRRequestInterceptor<T>;
     showLoading?: boolean;
   }
   ```

4. 添加全局公共的拦截器——每个对象的公共逻辑

   添加对象拦截器——某个对象的差独有的拦截器

   添加方法拦截器——调用某个方法时调用的拦截器

   ```typescript
   import axios from "axios";
   import type { AxiosInstance } from "axios";
   import type { HRRequestInterceptor, HRRequestConfig } from "./type";
   
   const DEFAULT_LOADING = false;
   
   class HRRequest {
   	// Axios实例
     instance: AxiosInstance;
     // interceptor拦截器
     interceptor: HRRequestInterceptor;
     
     constructor(config: HRRequestConfig) {
       this.instance = axios.create(config);
       
       // 公共的拦截器——所有的实例都会有的拦截器
       this.instance.interceptors.request.use(
         (config) => {
           console.log('所有的实例都会有的拦截器: 请求成功的拦截');
           return config;
         },
         (error) => {
           console.log('所有的实例都会有的拦截器: 请求失败的拦截');
           return error;
         }
       );
   
       this.instance.interceptors.response.use(
         (response) => {
           console.log('所有的实例都会有的拦截器: 响应成功的拦截');
           const data = response.data;
           if(data.code !== 0) {
             console.log('请求失败');
             switch(data.code) {
               case -1:
                 // TODO...
                 break;
               default: 
                 // TODO...
             }
           }
   
           // return response;
           return data;
         },
         (error) => {
           console.log('所有的实例都会有的拦截器: 响应失败的拦截');
           
           /**
            * 请求本身出错
            * 响应失败的拦截——HTTP状态码不是2xx时，会触发。
            * error的数据类型和服务器的设计有关系，需要配合服务器设计的返回值结构进行编码
            * 这里需要进行统一的错误处理，建议使用antd或者Element-plus的message组件进行提示
            */
   
           const statusCode = error.response.status;
           switch(statusCode) {
             case 401:
               // 401错误，token过期，需要重新登录，直接跳到登录页。
               // TODO...
               break;
             case 404:
               console.log('404');
               break;
             default:
               console.log('default');
           }
   
           // TODO...
           return error;
         }
       )
       
       // 实例的拦截器——从config中获取的拦截器
       this.instance.interceptors.request.use(
         this.interceptor?.requestInterceptor, 
         this.interceptor?.requestCatchInterceptor
       );
   
       this.instance.interceptors.response.use(
         this.interceptor?.responseInterceptor,
         this.interceptor?.responseCatchInterceptor
       );
     }
     
     
     // request实例方法
     request<T>(config: HRRequestConfig<T>): Promise<T> {
       // 返回一个Promise对象
       return new Promise((resolve, reject) => {
         if(config.interceptor?.requestInterceptor) {
           config = config.interceptor.requestInterceptor(config);
         }
     
         this.instance.request<any, T>(config).then(res => {
           if(config.interceptor?.responseInterceptor) {
             res = config.interceptor.responseInterceptor(res);
           }
           resolve(res);
         }).catch(err => {
           reject(err);
         });
       });
     }
   }
   
   export default HRRequest;
   ```

5. 添加token拦截、全局错误拦截

   ```typescript
   import axios from "axios";
   import type { AxiosInstance } from "axios";
   import type { HRRequestInterceptor, HRRequestConfig } from "./type";
   
   const DEFAULT_LOADING = false;
   
   class HRRequest {
   	// Axios实例
     instance: AxiosInstance;
     // interceptor拦截器
     interceptor: HRRequestInterceptor;
     
     constructor(config: HRRequestConfig) {
       this.instance = axios.create(config);
       
       // 公共的拦截器——所有的实例都会有的拦截器
       this.instance.interceptors.request.use(
         (config) => {
           console.log('所有的实例都会有的拦截器: 请求成功的拦截');
           return config;
         },
         (error) => {
           console.log('所有的实例都会有的拦截器: 请求失败的拦截');
           return error;
         }
       );
   
       this.instance.interceptors.response.use(
         (response) => {
           console.log('所有的实例都会有的拦截器: 响应成功的拦截');
           return response;
         },
         (error) => {
           console.log('所有的实例都会有的拦截器: 响应失败的拦截');
           return error;
         }
       )
       
       // 实例的拦截器——从config中获取的拦截器
       this.instance.interceptors.request.use(
         this.interceptor?.requestInterceptor, 
         this.interceptor?.requestCatchInterceptor
       );
   
       this.instance.interceptors.response.use(
         this.interceptor?.responseInterceptor,
         this.interceptor?.responseCatchInterceptor
       );
     }
     
     
     // request实例方法
     request<T>(config: HRRequestConfig<T>): Promise<T> {
       // 返回一个Promise对象
       return new Promise((resolve, reject) => {
         if(config.interceptor?.requestInterceptor) {
           config = config.interceptor.requestInterceptor(config);
         }
     
         this.instance.request<any, T>(config).then(res => {
           if(config.interceptor?.responseInterceptor) {
             res = config.interceptor.responseInterceptor(res);
           }
           resolve(res);
         }).catch(err => {
           reject(err);
         });
       });
     }
   }
   
   export default HRRequest;
   ```

   

6. 添加Loading效果

   ```typescript
   import axios from "axios";
   import type { AxiosInstance } from "axios";
   import type { HRRequestInterceptor, HRRequestConfig } from "./type";
   
   const DEFAULT_LOADING = false;
   
   class HRRequest {
     instance: AxiosInstance;
     interceptor?: HRRequestInterceptor;
     showLoading: boolean;
   
     constructor(config: HRRequestConfig) {
       this.instance = axios.create(config);
       // Loading效果默认显示
       this.showLoading = config.showLoading ?? DEFAULT_LOADING;
       this.interceptor = config.interceptor;
   
       // 公共的拦截器——所有的实例都会有的拦截器
       this.instance.interceptors.request.use(
         (config) => {
           console.log('所有的实例都会有的拦截器: 请求成功的拦截');
   
           // loading效果
           if(this.showLoading) {
             // TODO...
           }
   
           return config;
         },
         (error) => {
           console.log('所有的实例都会有的拦截器: 请求失败的拦截');
           return error;
         }
       );
   
       this.instance.interceptors.response.use(
         (response) => {
           console.log('所有的实例都会有的拦截器: 响应成功的拦截');
   
           // 将loading效果关闭
           // TODO...
   
           const data = response.data;
           if(data.code !== 0) {
             console.log('请求失败');
             switch(data.code) {
               case -1:
                 // TODO...
                 break;
               default: 
                 // TODO...
             }
           }
   
           // return response;
           return data;
         },
         (error) => {
           console.log('所有的实例都会有的拦截器: 响应失败的拦截');
   
           // 将loading效果关闭
           // TODO...
   
           /**
            * 请求本身出错
            * 响应失败的拦截——HTTP状态码不是2xx时，会触发。
            * error的数据类型和服务器的设计有关系，需要配合服务器设计的返回值结构进行编码
            * 这里需要进行统一的错误处理，建议使用antd或者Element-plus的message组件进行提示
            */
   
           const statusCode = error.response.status;
           switch(statusCode) {
             case 401:
               // 401错误，token过期，需要重新登录，直接跳到登录页。
               // TODO...
               break;
             case 404:
               console.log('404');
               break;
             default:
               console.log('default');
           }
   
           // TODO...
           return error;
         }
       )
   
       // 实例的拦截器——从config中获取的拦截器
       this.instance.interceptors.request.use(
         this.interceptor?.requestInterceptor, 
         this.interceptor?.requestCatchInterceptor
       );
   
       this.instance.interceptors.response.use(
         this.interceptor?.responseInterceptor,
         this.interceptor?.responseCatchInterceptor
       );
     }
   
     request<T>(config: HRRequestConfig<T>): Promise<T> {
       return new Promise((resolve, reject) => {
         if(config.interceptor?.requestInterceptor) {
           config = config.interceptor.requestInterceptor(config);
         }
     
         if(config.showLoading) {
           this.showLoading = config.showLoading;
         }
     
         this.instance.request<any, T>(config).then(res => {
           if(config.interceptor?.responseInterceptor) {
             res = config.interceptor.responseInterceptor(res);
           }
           console.log(res);
     
           // 请求结束后showLoading置为默认值
           this.showLoading = DEFAULT_LOADING;
   
           resolve(res);
         }).catch(err => {
           // 请求结束后showLoading置为默认值
           this.showLoading = DEFAULT_LOADING;
           reject(err);
         });
       });
     }
   
     get<T>(config: HRRequestConfig<T>): Promise<T> {
       return this.request({ ...config, method: "GET" });
     }
   
     post<T>(config: HRRequestConfig<T>): Promise<T> {
       return this.request({ ...config, method: "POST" });
     }
   
     put<T>(config: HRRequestConfig<T>): Promise<T> {
       return this.request({ ...config, method: "PUT" });
     }
   
     delete<T>(config: HRRequestConfig<T>): Promise<T> {
       return this.request({ ...config, method: "DELETE" });
     }
   }
   
   export default HRRequest;
   ```



### III、添加统一service的出口——token拦截

```typescript
// service的统一出口
import HRRequest from "./request"
import { BASE_URL, TIME_OUT } from "./config"

export default new HRRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptor: {
    requestInterceptor: (config) => {

      // 携带token的拦截
      /**
       * token一般存储在状态管理工具内，或者localStorage或者sessionStorage中
       * 这里以localStorage为例
       */
      const token = localStorage.getItem("token") || '';
      
      if(token && config.headers) {
        config.headers.Authorization = `Bearer ${token}`;
      }

      console.log('单个实例请求成功的拦截');
      return config
    },
    requestCatchInterceptor: (error) => {
      console.log('单个实例请求失败的拦截');
      return error
    },
    responseInterceptor: (response) => {
      console.log('单个实例响应成功的拦截');
      return response;
    },
    responseCatchInterceptor: (error) => {
      console.log('单个实例响应失败的拦截');
      return error;
    }
  }
});
```

