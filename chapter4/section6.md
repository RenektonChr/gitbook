# 认识复杂度和简单排序算法



## 零、写在前面

算法和数据结构有什么用？为什么大厂的面试算法和数据结构都是必问的？

作为一般的程序员，进入公司实际上只做一件事，那就是完成公司的业务，这一点不论前端程序员还是后端程序员都是一样的，这在互联网发展的初期，国内的公司都是这么做的。但是随着互联网的发展，公司的业务复杂度上升，在各自抢占的市场内需要不断改进和优化自己的产品。这时候算法和数据结构的重要性就完全凸显出来了——一个合适的数据结构搭配上优秀的算法可以使程序的性能提高千百倍甚至更多，毫无疑问，中国现在的互联网市场已经慢慢的过渡到了这个阶段。

至于业务的熟练程度可以看文档然后在日常的工作中得到提升，但是算法和数据结构的提升则是非常缓慢的。这也是评价一个程序员是否合格，是否聪明的唯一指标。看到这里或许很多兄弟可能不服气，但很遗憾确实是这样的。



## 一、时间复杂度

所谓时间复杂度就是估计常数时间操作的指标。

**什么是常数时间的操作？**

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**。

举个例子：

+ 通过数组的下标取出数组的某一项，不管是数组有多少项，在计算机中只是计算一个偏移量然后根据偏移的位置把数组中的项取出来，那么这就是一个常数时间的操作。
+ 对比链表，链表取出某一项，是要从第一项往后开始逐个查找，取出第一项和第n项（假设n足够大）的时间和问题的规模就成正比例关系。那么链表的查询就不是一个常数时间的操作。

**时间复杂度：**

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O（读作：big O）来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中发生了多少常数操作，归纳总结出常数操作数量的表达式。

**时间复杂度的表达式：**

归纳总结出常数操作数量的表达式之后，去掉低阶项和常数项，剩下的高阶项如果为f(N)，那么算法的时间复杂度的表达式就为`O(f(N))`。

**如何评价两个算法之间的好坏？**

先比较复杂度的表达式，阶数低的自然就好，如果表达式相同，那么就要运行程序实际测试。



## 二、选择排序

现在我们来看一下选择排序这个算法的具体操作，以选择排序为例，详细阐述一下时间复杂度的计算。

**利用选择排序来从小到大的排序一个无序的数组。**

**选择排序的解析：**

+ 设无序的数组的项数为N项，那么下标就是从0到N-1。
+ 我们从0 ~（N-1）的范围内选出一个最小的值，把这个最小的值与数组第0位置的数字进行交换。
+ 然后我们从1 ~ （N-1）的范围内选出一个最小的值，把这个最小的值与数组第1位置的数字进行交换。
+ 接着我们从2 ~ （N-1）的范围内选出一个最小的值，把这个最小的值与数组第2位置的数字进行交换。
+ ....

我们可以看出经过有限次的重复操作，一个无序的数组就可以成为一个有序的数组。我们来看一下一共经过了几次比较和几次交换：

+ 第一轮比较，实际上是从N个数中找出最小的值，需要N次比较，一次交换。
+ 第二轮比较，是从N-1个数中找出最小的值，需要N-1次比较，一次交换。
+ ......

综上所述，我们可以得出一个推论一共进行了 `N + N-1 + N-2 + .... + 1` 次比较和N次交换。

可以发现交换的次数的表达式是一个等差数列求和，根据等差数列的求和公式：

<img src="../assets/images/chapter4/01.svg" alt="node-app.png" style="zoom:80%;" />

我们可以得出，选择排序的常数时间的表达式一定是 `aN² + bN + c`，其中a、b、c都是常数。根据时间复杂度的定义，我们把低阶项去掉，把高阶项的系数去掉，最后剩下的才是时间复杂度的表达式，即 `n²`，所以我们可以得出最终结论：

**选择排序的时间复杂度为O(N²)。**

另，关于O的含义，在数学上O指的是上限的意思。

> 现在我们来思考一个问题：**为什么在讨论算法的时间复杂度的时候我们直接干掉低阶项和高阶项的系数呢？**
>
> 其实这个问题很好理解，对于一个算法的时间复杂度来说，当数据量到达一定的级别，影响时间复杂度的最主要的因素就是最高阶项，也就是说最高阶项是整个算法的时间复杂度的性能瓶颈。低阶项和系数对于时间复杂度的影响微乎其微。

**关于额外空间复杂度：**

如果算法中只需要几个确定的变量，那么这个算法的额外空间复杂度就是O(1)的。

如果算法中需要一个额外的数组，而且额外的数组和原本数据的数组是等规模的，那么这个算法的额外空间复杂度就是O(N)。

选择排序的额外空间复杂度就是O(1)。让我们来看一下JS的选择排序的实现，我们就知道为什么选择排序的空间复杂度是O(1)了：

```javascript
// 选择排序

function selectionSort(arr) {
  const length = arr.length;
  let minIndex;
  if(arr == null || length <= 2) {
    return;
  }
  for (var i = 0; i < len - 1; i++) {
    minIndex = i;
    for (var j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {     // 寻找最小的数
        minIndex = j;                 // 将最小数的索引保存
      }
    }
    // 交换
    swap(arr, i, minIndex);
  }
  return arr;
}

function swap(arr, i, minIndex) {
  let temp = arr[i];
  arr[i] = arr[minIndex];
  arr[minIndex] = temp;
}
```

通过JS的实现代码我们可以看出，选择排序算法中额外使用了`length、minIndex、temp`三个变量，所以额外的空间复杂度为O(1)。

**选择排序的示意图：**

<img src="../assets/images/chapter4/selectionSort.gif" alt="node-app.png" style="zoom:80%;" />

选择排序是一种非常直观的排序算法，非常易于理解，但是一个最大的弊端就是不管什么数据进去都是O(N²)的复杂度，如果数据量很大，效率会很低。

## 三、冒泡排序

冒泡排序也很简单，一句话总结：比较相邻的两个数，如果第一个比第二个大，就交换他们两个，否则不动。

**利用冒泡排序，从小到大排序一个无序数组。**

**冒泡排序的解析：**

+ 设无序数组为N项，下标为0 ~ N-1。
+ 第一次，0位置和1位置的数作比较，如果0位置的数比1位置的数字大，则交换位置，否则什么也不做。
+ 第二次，1位置和2位置的数作比较，如果1位置的数比2位置的数字大，则交换位置，否则什么也不做。
+ 重复上述做法，那么会把最大的数字移动到N-1位置。这样就冒出了最大的数字。
+ 然后再从0~N-2位置的所有数字中挑选中次大的数字。
+ 重复操作后，整个数组就会变成有序的。

根据算法的步骤我们可以得出：

在挑出最大数字的时候，做了N次比较。次大的数时，做了N-1次比较...以此类推，一共做了 `N + N-1 + N-2 + ... + 1` 次比较，根据等差数列求和公式我们可以得知，最终一定是做了：`aN² + bN + c`次比较，和选择排序相同，去掉低阶项和高阶项的系数，最终冒泡排序的时间复杂度为O(N²)。

**冒泡排序的JS实现：**

```javascript
// 冒泡排序

function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len - 1; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                swap(arr, j, j + 1)
            }
        }
    }
    return arr;
}

// 交换arr中 i 位置和 j 位置上的数字
function swap(arr, i, j) {
  arr[i] = arr[i] ^ arr[j];
  arr[j] = arr[i] ^ arr[j];
  arr[i] = arr[i] ^ arr[j];
}
```

**冒泡排序的示意图：**

<img src="../assets/images/chapter4/bubbleSort.gif" alt="node-app.png" style="zoom:80%;" />

冒泡排序的代码没有什么难度，但是我们仔细观察一下上面的代码就会发现一个有意思的事情，那就是我们在实现swap函数时用的是异或的运算。

下面我们来讲一下**异或运算**。

### 异或运算

稍微学过计算机组成原理的读者都会知道异或有一个性质：不同为1，相同为0。我们可以把两个二进制数字进行异或运算：`10110 ^ 00111`，异或之后的结果为`10001`（大家可以用笔算一下）。

​	1 0 1 1 0

^ 0 0 1 1 1 

————————

​	1 0 0 0 1

我们可以根据上面的异或运算得出另外一条结论：`异或还可以理解为无进位相加。`

**异或运算的性质：**

+ 0 ^ N = N
+ N ^ N = 0
+ 异或运算满足交换律和结合律：
  + a ^ b = b ^ c
  + a ^ b ^ c = (a ^ b) ^ c
+ 多个数以不同的顺序异或，最终的结果是一定的，即多个数异或的结果不受异或顺序的影响。

了解了异或运算的性质，我们来解释一下为什么swap函数可以使用异或运算实现。

想要解释这个问题，我们需要使用`代入法`。

```javascript
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

+ 假设现在有a、b两个值。a的值我们用`甲`来表示，b的值我们用`乙`来表示。
+ 第一个语句为：a = 甲 ^ 乙。
+ 第二个语句为：b = 甲 ^ 乙 ^ 乙。根据异或运算满足结合律：甲 ^ 乙 ^ 乙 <=> 甲 ^ (乙 ^ 乙) => 甲 ^ 0 => 甲，所以当前b为甲。
+ 第三个语句为：a = 甲 ^ 乙 ^ 甲。根据异或运算满足交换律和结合律：a = 甲 ^ 甲 ^ 乙  => 0 ^ 乙 => 乙。
+ 经过运算，最终结果为`a = 乙、b = 乙`。

> 这种交换方法还有一个使用前提：
>
> **a和b在内存中必须是两个独立的区域，才能使用异或进行交换。**

### 关于异或运算的面试题：

**第一题：**

一个整数数组中只有一种树出现了奇数次，其他的数字都出现了偶数次。

（1）求出出现了奇数次的数字。

（2）如果已知有两种数出现了奇数次，其他所有的数字都出现了偶数次，求出这两种数字。

要求：时间复杂度O(N)，空间复杂度O(1)。

**分析：**

（1）求解第一问很容易，声明一个变量`eor = 0`，然后直接遍历数组，让数组的每一项都与eor做异或操作，然后赋值给`eor`。`eor`就是要求的出现了奇数次的数字。

（2）不妨设两个出现奇数次的数字是a和b，如果我们声明一个变量`eor = 0`，然后进行第一问的操作，毫无疑问最后eor一定等于`a^b`。又因为是两种数，所以我们知道`a != b`。综上我们可以得出几个结论：

+ `eor = a ^ b`
+ 因为`a != b`所以可以得到`a ^ b != 0`。
+ eor一定在某一位上不等于0

现在我们假设eor在第八位上是1，这就说明a和b在第八位上一定是不一样的，肯定是一个为0一个为1。那么我们现在声明一个`eor = 0'`，然后把数组中第八位不是1的数字全部和`eor'`进行异或操作。那么现在`eor'`的结果就是a或者b了（这个问题怎么理解？）。

先解释一下为什么`eor’`是a或者b？

我们可以把arr数组中所有的数字分为两类：

+ 一类是第八位上是1的数字。
+ 另一类是第八位上是0的数字。

a和b是不会同时存在于这两个集合里的，因为除了a或者b其他的数字都出现了偶数次，所以`eor'`最后只能是a或者b。现在我们可以得出`ero`和`eor‘`的值：

+ eor = a ^ b
+ eor' = a or b

现在我们已经得到了a、b两个数中的一个，另一个我们可以通过 `eor ^ eor'`来得到。

**至此我们已经解决了这道面试题的全部两问。此处应该有掌声~**

**题解：**

```javascript
// 第一问求解

function fun(arr) {
  let eor = 0;
  const len = arr.length;
  
  for(let i = 0; i < len; i++) {
    eor ^= arr[i];
	}
  
  return eor;
}


// 第二问求解
function fun2(arr) {
  let eor = 0;
  arr.forEach(item => {
    eor ^= item;
  });
  // eor = a ^ b
  // eor != 0
  // eor必然有一个位置上为1
  let rightOne = eor & (~eor + 1);	// 提取中最右侧的1
  let onlyOne = 0;
  arr.forEach(item => {
    if(item ^ rightOne === 1) {
      onlyOne ^= item;
    }
  });
  
  let a = onlyOne;
  let b = eor ^ onlyOne;
}
```

> **Tips: 为什么说异或的结果不受异或顺序的影响？**
>
> 可以用“异或可以看成无进位相加”这一推论来解释这个问题。我们知道两个数字做异或运算，在计算机中这两个数字都是以二进制来表示的，而异或操作实际上可以看成是无进位相加，所以异或的结果每一位是0还是1取决于异或的这几个二进制数的相同位置上的0或者1的个数，和具体的位置无关，所以可以得出结论：
>
> **异或的结果不受异或顺序的影响。**



## 四、插入排序

插入排序是最后一个时间复杂度为O(N²)的排序算法，但是和选择排序、冒泡排序不同的是插入排序的时间复杂度与数据情况相关，如果数据本身就是有序的那么插入排序的时间复杂度是O(N)，如果数据的情况为完全无序的，那么插入排序的时间复杂度为O(N²)。

### 什么是插入排序？

其实插入排序也是非常容易理解的，在我们日常的生活中运用的最为广泛，也有很多的实际生活的模型。最常见的就是`斗地主`，在斗地主抓牌的时候，我们总会把新抓上来的牌和我们手中的牌从右到左一次对比，找到合适的位置（也就是小于等于当前新抓到牌的位置）插入进去。**这就是插入排序！**

### 插入排序的分析

我们现在有一个长度为N的整数数组`arr`。位置下标为`0 ~ (N-1)`

+ 首先，我们要保证`0~0`位置上是有序的，这是显然有序的（就一个数字当然有序）。
+ 然后，我们要保证在`0~1`位置上是有序的，那么我们就要让当前1位置上的数字和0位置上的数字做比较，如果1位置上的数字比0位置上的数字小则1位置上的数字往左移动。也就是和0位置上的数字交换。
+ 接着，我们要保证在`0~2`位置上是有序的，那么就要让2位置上的数字同他左边所有的数字依次比较，如果比左边的数字小，则交换。否则不动。
+ 这样一直到数组的第N-1位置的数字重复完上述操作。整个数组就是有序的。

> **注意：数字交换的条件？**
>
> 交换的条件是当前的数字与左边的数字相比，当前数字的下标不为0（也就是说当前数字的位置的左边还有数字）并且小于左边数字才交换。

### 插入排序的动图演示

<img src="../assets/images/chapter4/insertionSort.gif" alt="node-app.png" style="zoom:80%;" />

### 插入排序的算法实现

```javascript
// 插入排序的JS实现

function insertionSort(arr) {
  if(arr == null || arr.length < 2) { 
    return; 
  }
  const len = arr.length;
  for(let i = 1; i < len; i++) {
    for(let j = i-1; j >= 0 && arr[j] > arr[j+1]; j--) {
      swap(arr, j, j+1);
    }
  }
}

function swap(arr, i, j) {
  arr[i] = arr[i] ^ arr[j];
  arr[j] = arr[i] ^ arr[j];
  arr[i] = arr[i] ^ arr[j];
}
```

### 为什么说插入排序的时间复杂度与数据情况相关？

如果我们拿一个本身就有序的数组，例如`[1,2,3,4,5,6,7]`。利用插入排序的算法来做，在比较的时候不需要进行交换。所以只需要比较N次就OK了，时间复杂度为O(N)。

如果一个完全无序的数字，例如 `[7,6,5,4,3,2,1]` 利用插入排序。

+ 0~1位置上有序，需要和一个数交换。
+ 0~2位置上有序，需要和两个数交换。
+ 0~3位置上有序，需要和三个数交换。
+ 0~4位置上有序，需要和四个数交换。
+ ...

我们可以看到交换的次数是一个等差数列，所以这个问题的时间复杂度是`O(N²)`。

那么问题就来了，对于像插入排序这种时间复杂度和数据情况相关的算法，时间复杂度应该是什么呢？这就需要我们了解一下不同的算法复杂度描述形式

> Ω：最优算法复杂度
>
> O：最差算法复杂度
>
> θ：平均算法复杂度

从算法学习的角度来讲，最优和平均算法复杂度的指标是没有意义的。我们只需要掌握O的算法复杂度描述就可以。记住一个准则：**算法流程按照最差情况来估计时间复杂度。**



## 五、二分法的详解与扩展

### I、什么是二分法？

在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**二分查找算法**，也称**折半搜索算法**、**对数搜索算法**，是一种在[有序数组](https://zh.wikipedia.org/wiki/有序数对)中查找某一特定元素的搜索[算法](https://zh.wikipedia.org/wiki/算法)。二分查找算法在[最坏情况](https://zh.wikipedia.org/w/index.php?title=最坏情况&action=edit&redlink=1)下是[对数时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度#对数时间)的，需要进行`O(logN)`次比较操作。

### II、二分法的使用场景

+ 在一个有序数组中查找某个数是否存在。
+ 在一个有序数组中，找>=某个数最左侧的位置，或者找<=某个数最右侧的位置。
+ 局部最小值问题



## 六、学会使用对数器（自行解决这个问题）

+ 什么是对数器？
+ 对数器解决了什么问题？
+ 怎么使用对数器？



