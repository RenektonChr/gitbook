# HTTP协议那些事儿

## 零、写在前面

这篇文章我们将探讨一下内容：

+ 密码学入门





## 一、密码学入门

**密码学处理的对象是数字和字符串**，在计算机里面本质上所有的东西都是数字（二级制数字）。我们在做登录功能的时候，有时会进行md5加密，本质上md5是一种散列运算，是不可逆的。而我们一般的加密都是在做异或运算或者移位，是可以恢复的。

**散列是一种数据一旦转换为其他形式将永远无法恢复的加密形式。**一般的我们说加密，是可以正向加密成密文，然后偶反向可以根据密文解密出原文，我们看一张图片：

<img src="../assets/images/chapter7/http16.png" alt="node-app.png" style="zoom:80%;" />

我们先看Encryption（加密），原始数据（Plain Text）也就是明文，加上秘钥，两者经过加密算法的处理加密成密文。然后就是Decryption（解密），密文加上秘钥经过解密算法还原出明文。这个过程就是加密和解密，需要注意的是加密和解密是一个可逆的过程，md5是一个散列的算法，是不可逆的，所以严格来说，MD5不是加密。

加密的方式分为两种：

+ 对称加密：加密和解密的秘钥相同，则是对称加密。常见的对称加密算法有：AES、DES、3DES。
+ 非对称加密：加密和解密的秘钥不同，则是非对称加密。常见的非对称加密算法有：RSA。

我们先来看对称加密，对称加密中有两个算法很像，DES和3DES，这两种算法的区别就在于DES是做一次DES运算，3DES是做三次DES运算。非对称加密需要有公钥和私钥，其中最著名的就是RSA算法，RSA是个商用的加密算法，这种算法的保密是非常严格的，不只是私钥保密就连算法本身都是保密的。但是RSA比较特殊，算法是公开的，只需要保存好秘钥就OK。

不对称加密的秘钥需要有两个，公钥和私钥，使用公钥加密，私钥解密。一般我们把公钥公开出去，加密的密文也可以公开，私钥保存好。用自己的私钥解密，这就保证了密文的安全。如果想破解非对称加密，就需要生成很多的私钥，一个个去试，所以要想破解RSA需要有强大的算力的计算机。

在密码学中，加密算法只是一部分，还有很大一部分是保证秘钥的安全性。密码学更多的是研究密码的安全。接下来我们来说一下秘钥交换算法：

### 秘钥交换算法

秘钥在交换的时候，很有可能被截获，也有可能在传输的时候被窃听，那么就要使用Diffie-Hellman，Diffie-Hellman交换算法是一种著名的秘钥协商算法，这种算法可以使得信息交换的双方通过公开的非安全的网络协商生成安全的共享秘钥。

我们设定两个人Alice和Bob，交换秘钥，看一下交换的算法（Diffie-Hellman交换算法）：

1. Alice与Bob确定两个大的素数n和g，这两个素数不用保密。注意：在密码学中找到大素数是很重要的一个步骤，一般使用椭圆算法。
2. Alice选择一个大的随机数x，并计算A如下：A = gx mod n;
3. Alice将A发给Bob。
4. Bob选择另一个大随机数y，并计算B如下：B = gy mod n;
5. Bob将B发给Alice。
6. 计算秘密秘钥K1如下：K1 = Bx mod n
7. 计算秘密秘钥K2如下：K2 = Ay mod n
8. K1 = K2，因此Alice和Bob可以用其进行加密和解密

**HTTPS的加密，TLS ，SSL就是用的秘钥交换算法。**HTTP加密的作用就是提供一个不被篡改的依据。

### HTTPS的网站证书

我们在访问HTTPS的网站时，会下载一个证书，这个证书会和你本地的证书做验证，如果验证通过就可以访问。本地的证书在安装操作系统或者浏览器的时候会添加到本地。证书可以验证服务器的身份，反过来也可以验证客户端的身份。

发证书的是具有公信力的权威的第三方机构，这个机构就是CA。中国也有自己的CA机构。根证书还可以签发二级认证机构，一旦二级认证机构的证书泄漏，就废掉二级签发机构，尽可能的把损失降低，同时这也是一种安全策略。

CA的工作流程：

+ 服务器example.com将从CA请求TLS证书，例如Digiert。浏览器通过根证书验证网站的证书是否合法。
+ Digiert将为example.com创建证书，证书将包含必要的数据，例如服务器的名称，服务器的公钥等。
+ Digiert创建证书的hash值，并使用自己的私钥对其进行加密。
+ 浏览器和操作系统自带Digiert等权威机构的公钥。
+ 当浏览器收到签名证书的时候，它将使用公钥和签名生成哈希值，它还将使用证书中执行的散列算法生成证书的散列数据。如果两个哈希值匹配（一致），则签名验证成功并且证书的可信的。
+ 现在，浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。



## 二、TLS和SSL协议

我们先来看一张图：

<img src="../assets/images/chapter7/http17.png" alt="node-app.png" style="zoom:80%;" />

这张图描述了SSL在五层协议和七层协议中的具体位置，在TCP/IP五层协议中，SSL/TLS协议是嵌入到应用层的，不属于单独的一层。但是在七层协议中是插入到应用层和传输层之间的，属于单独的一层。

+ 传输层安全协议TLS（Transport layer security）和其前身安全套接层（Secure Sockets Layer - SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。TLS是SSL的后续版本，兼容SSL。
+ HTTP协议的安全性由SSL协议实现，现在的SSL是TLS的一部分，当前使用的TLS1.2版本包含了四个子协议：握手协议、秘钥配置切换协议、应用数据协议，及报警协议。我们先来说一下这四个协议各自干了些什么：
  + 握手协议：TCP在建立连接的时候本身是不能加密的，在TCP连接之后再进行加密连接握手。也就是双方进行加密协商，加密协商中最终要的东西就是秘钥交换。首先要保证链路是安全的，才能进行后续的操作。所以握手的过程是包含秘钥交换的。这也是整个过程最危险的一步。
  + 秘钥配置切换协议：在握手的时候使用的是对称加密，然后这一步骤要把对称加密切换成不对称加密。双方交换不对称秘钥。究竟用那种加密算法也在这一步协商。
  + 应用数据协议：数据该怎么进行传输
  + 报警协议：当安全性出现问题时，比如证书过期时，报警协议会报警。
  + **TLS适用于对称加密**
  + **对称秘钥可以通过安全秘钥交换算法共享**
  + **如果请求被截获，秘钥交换可能被欺骗**
  + **使用数字签名进行身份验证**
  + **证书颁发机构和信任链**
+ HTTPS协议、SSL协议、TLS协议、握手协议的关系
  + HTTPS是Hypertext Transfer Protocol over Secure Socket Layer的缩写，即**HTTP over SSL**，可以理解为基于SSL的HTTP协议。HTTPS的安全性是由SSL协议实现的。
  + SSL协议是TLS协议的前身，SSL协议是一种记录协议，扩展性良好，可以添加子协议。
  + 握手协议是SSL协议的一个子协议。

## 三、HTTPS的协议分析

我们先来看一张HTTPS协议的图：

<img src="../assets/images/chapter7/http18.png" alt="node-app.png" style="zoom:50%;" />

对于HTTP的协议分析，主要是在最后的S上，也就是**TLS的握手过程的分析**，那么我们在面试中最经常问到的也就是两个握手，第一个就是TCP连接的握手，第二个就是就是TLS的握手。

那么我们就来分析一下HTTPS中TLS的握手步骤：

1. ClientHello：客户端发送所支持的SSL/TLS最高协议版本号和所支持的加密算法集合以及压缩方法集合等信息给服务端。
2. ServerHello：服务器端接收到客户端信息后，返回服务器和客户端都支持的加密算法和压缩方法返回客户端。
3. SendCertificate(可选)：服务端发送服务端的证书给客户端。
4. RequestCertificate(可选)：如果选择双向验证，服务端会向客户端请求客户端的证书。
5. ServerHelloDone：服务器端通知客户端初始协商结束。
6. ResponseCertificate(可选)：如果选择双向验证，客户端向服务端发送客户端的证书。
7. ClientKeyExchange：客户端使用服务器端的公钥，对客户端公钥和私钥种子（大随机数）进行加密。在发送给服务器端。
8. CertificateVerify(可选)：如果选择双向验证，客户端用本地私钥生成数字签名（用来验证第六步的客户端证书），并发送给服务器端，让其通过收到的客户端公钥进行身份验证。
9. CreateSecretKey：通讯双方通过秘钥种子等信息，生成通信秘钥。
10. ChangeCipherSpec：客户端通知服务器端已经将通讯方式切换成加密方式。
11. Finished：客户端做好加密通讯的准备。。
12. ChangeCipherSpec：服务器端通知客户端已将通讯方式切换到加密模式。
13. Finished：服务器做好加密通信的准备。
14. Encrypted/DecryptedData：双方使用客户端秘钥，通过对称加密算法对通讯内容进行加密。
15. ClosedConnection：通讯结束后，任何一方发出断开 SSL 连接的消息。

第一步是客户端给服务端发信息，第二步是服务端向客户端做响应，前两步是客户端和服务端进行加密协商。

接下来是三、四、五步，首要的是要把服务器的证书发给客户端，如果需要双向验证，还需要请求客户端的证书。

反过来是六、七、八步，这三步是客户端在干活了，如果客户端选择了双向验证，就需要发送自己的证书给服务端。

第一步到第八步都是明文通信还没加密。从第十步到第十三步都是秘钥的交换过程，属于协商阶段。这些完事儿之后就可以加密通信了。

从第十四步开始就是加密之后的通信，**真正的加密过程就是第一步到第十三步。**通信结束之后断开连接，要先断开加密连接也就是TLS连接，然后再断开TCP连接。



### HTTP2协议分析

